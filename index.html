 <!DOCTYPE html>

<! 3D Cloth Simulation                  >
<!                                      >
<! Written by:  Evan Newman             >
<! Date:        February 2020           >
<! Contact      evanmnewman1@gmail.com  >

<html>

<head>

<meta charset="UTF-8">
<title>3D Cloth</title>

<script src='Abubu.js' type='text/javascript'></script>
<script src='shaders.js' type='text/javascript'></script>
<script src='ClothLib.js' type='text/javascript'></script>

</head>

<body>
<canvas  id="main-canvas" 
         width=512 height=512
         style="border:1px solid #000000;" >
   <!-- This message is displayed if canvas is not available -->
   Your browser does not support the HTML5 canvas tag.
</canvas>

<script>
	/*TODO
	add support for non-square cloths
		set the grid point generator to output points as before
		take scale, width, and height as uniforms to determine pixel position

	
	*/

	console.log('--- 3D Cloth Simulation by Evan Newman ---');

	var modelParams = {
		clothWidth : 5,
		clothHeight : 10,
		clothScale : 1.0,
		timestep : 1,
		displayWidth : 512,
		displayHeight : 512,
		sheerK : 0.1,
		tensionK : 0.1,
		foldK : 0.1
	}

	var mainCanvas = document.getElementById('main-canvas');
	mainCanvas.width = modelParams.displayWidth;
	mainCanvas.height = modelParams.displayHeight;

	var camera = new CameraMatrixController();
	CameraMatrixController.addListeners(mainCanvas);

	var vertexPoints = genClothGridPoints(modelParams.clothWidth,
										  modelParams.clothHeight,
										  modelParams.scale);
	var geometryPoints = genClothGeometryPoints(modelParams.clothWidth,
												modelParams.clothHeight,
												vertexPoints);

	var init_displacements = new Float32Array(4*modelParams.clothWidth*modelParams.clothHeight);
	var init_k_ne_se_e1_s1 = new Float32Array(4*modelParams.clothWidth*modelParams.clothHeight);
	var init_k_e2_s2 = new Float32Array(4*modelParams.clothWidth*modelParams.clothHeight);

	for (var row = 0; row < modelParams.clothHeight; row++) {
		for (var col = 0; col < modelParams.clothWidth; col++) {
			var index = 4*(row*modelParams.clothWidth + col);
			if (col < (modelParams.clothWidth - 1)) {
				if (row > 0) {
					init_k_ne_se_e1_s1[index] = modelParams.sheerK;
				}

				if (row < (modelParams.clothHeight - 1)) {
					init_k_ne_se_e1_s1[index + 1] = modelParams.sheerK;
				}

				init_k_ne_se_e1_s1[index + 2] = modelParams.tensionK;
			}

			if (row < (modelParams.clothHeight - 1)) {
				init_k_ne_se_e1_s1[index + 3] = modelParams.tensionK;
			}

			if (col < (modelParams.clothWidth - 2)) {
				init_k_e2_s2[index] = modelParams.foldK;
			}

			if (row < (modelParams.clothHeight - 2)) {
				init_k_e2_s2[index + 1] = modelParams.foldK;
			} 

			init_displacements[index] = row*row*0.25;
		}
	}

	var e_displacements = new Abubu.Float32Texture(modelParams.clothWidth,
												   modelParams.clothHeight,
												   {data : init_displacements});
	var o_displacements = new Abubu.Float32Texture(modelParams.clothWidth,
												   modelParams.clothHeight,
												   {data : init_displacements});
	var k_ne_se_e1_s1 = new Abubu.Float32Texture(modelParams.clothWidth,
												 modelParams.clothHeight,
												 {data : init_k_ne_se_e1_s1});
	var k_e2_s2 	  = new Abubu.Float32Texture(modelParams.clothWidth,
												 modelParams.clothHeight,
												 {data : init_k_e2_s2});

	var displacementUpdater = new Abubu.Solver({
		vertexShader : passThroughVS,
		fragmentShader : displacementUpdaterFS,
		uniforms : {
			inDisplacements : {type: 't', value: e_displacements},
			k_ne_se_e1_s1   : {type: 't', value: k_ne_se_e1_s1},
			k_e2_s2			: {type: 't', value: k_e2_s2},
			width           : {type: 'i', value: modelParams.clothWidth},
			height          : {type: 'i', value: modelParams.clothHeight},
			scale			: {type: 'f', value: modelParams.clothScale}
		},
		renderTargets : {
			outDisplacements : {location: 0, target: o_displacements}
		}
	});

	var pointGeometry = {
		vertices : vertexPoints,
		noVertices : vertexPoints.length/3,
		noCoords : 3,
		premitive : 'points',
	};

	var pointPlotter = new Abubu.Solver({
		vertexShader : testVS,
		fragmentShader : pointRenderFS,
		geometry : pointGeometry,
		canvas : mainCanvas,
		clear : false,
		uniforms : {
			cameraMatrix : {type: 'mat4', value: camera.getCameraMatrix()},
			displacements : {type: 't', value: o_displacements},
			width           : {type: 'i', value: modelParams.clothWidth},
			height          : {type: 'i', value: modelParams.clothHeight},
			scale			: {type: 'f', value: modelParams.clothScale}
		}
	});

	
	var sheetGeometry = {
	    vertices : geometryPoints,
	    noVertices: geometryPoints.length/3, // No of vertices
	    noCoords  : 3, // No of coordinates
	    premitive : 'triangle_strip' ,
	};

	var testSheetSolver = new Abubu.Solver({
		vertexShader : testVS,
		fragmentShader : testSheetFS,
		geometry : sheetGeometry,
		canvas : mainCanvas,
		clear : true,
		uniforms : {
			cameraMatrix : {type: 'mat4', value: camera.getCameraMatrix()},
			displacements : {type: 't', value: o_displacements},
			width           : {type: 'i', value: modelParams.clothWidth},
			height          : {type: 'i', value: modelParams.clothHeight},
			scale			: {type: 'f', value: modelParams.clothScale}
		}
	});

	var lineGeometry = {
	    vertices : geometryPoints,
	    noVertices: geometryPoints.length/3, // No of vertices
	    noCoords  : 3, // No of coordinates
	    premitive : 'line_strip' ,
	};

	var testLineSolver = new Abubu.Solver({
		vertexShader : testVS,
		fragmentShader : testLineFS,
		geometry : lineGeometry,
		canvas : mainCanvas,
		clear : false,
		uniforms : {
			cameraMatrix : {type: 'mat4', value: camera.getCameraMatrix()},
			displacements : {type: 't', value: o_displacements},
			width           : {type: 'i', value: modelParams.clothWidth},
			height          : {type: 'i', value: modelParams.clothHeight},
			scale			: {type: 'f', value: modelParams.clothScale}
		}
	});

	var timestep = 0;
	var render = function() {
		camera.updateCameraMatrix();
		testSheetSolver.setUniform("cameraMatrix", camera.getCameraMatrix());
		testLineSolver.setUniform("cameraMatrix", camera.getCameraMatrix());
		pointPlotter.setUniform("cameraMatrix", camera.getCameraMatrix());

		if (timestep % 2 === 0) {
			displacementUpdater.setUniform('inDisplacements', e_displacements);
			displacementUpdater.setRenderTarget('outDisplacements', o_displacements);

			testSheetSolver.setUniform('displacements', o_displacements);
			testLineSolver.setUniform('displacements', o_displacements);
			pointPlotter.setUniform('displacements', o_displacements);
		} else {
			displacementUpdater.setUniform('inDisplacements', o_displacements);
			displacementUpdater.setRenderTarget('outDisplacements', e_displacements);

			testSheetSolver.setUniform('displacements', e_displacements);
			testLineSolver.setUniform('displacements', e_displacements);
			pointPlotter.setUniform('displacements', e_displacements);
		}

		displacementUpdater.render();
		testSheetSolver.render();
		testLineSolver.render();
		pointPlotter.render();

		requestAnimationFrame(render);

		timestep++;
	}
	render();

</script>

</body>
</html>